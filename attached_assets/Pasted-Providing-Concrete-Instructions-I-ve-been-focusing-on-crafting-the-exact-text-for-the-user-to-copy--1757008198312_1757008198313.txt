Providing Concrete Instructions

I've been focusing on crafting the exact text for the user to copy and paste into Replit.  My goal is to provide a precise, verbatim solution to meet their specific need for a readily executable starting point. I'm aiming for clarity and directness, avoiding any ambiguity or extraneous information.

Defining Focused Prompts

I'm now refining the format of the precise text the user will copy and paste into Replit.  I've decided on a series of focused, verbatim prompts for higher success and code quality. This approach allows for debugging between steps, ensuring each prompt builds upon the last in a logical sequence. My confidence is high that this will provide a smooth and efficient experience.

Designing Iterative Prompts

I've decided to structure my response as a series of specific, copy-paste prompts. This is due to an earlier simulation where a single, massive prompt proved unreliable. I'm focusing on creating an initial setup prompt, then a sequence of precise prompts building upon it. The strategy emphasizes quality and allows for debugging at each step.

Developing a Verbatim Structure

I've been working on structuring the response as a series of copy-paste prompts. My goal is to ensure the user receives precise instructions that are easily executable within Replit.  I'm now writing a brief introduction to explain the step-by-step approach and why it's structured this way, focusing on clarity and ease of use. I've designed the prompts in a modular way that builds upon each other for enhanced reliability.

Implementing Step-by-Step Instructions

I've been working on a complete step-by-step guide. It'll be a series of copy-paste prompts. I'll include explanations along with the prompts, to provide further clarity for the user.  The process will start with an introductory prompt to the structure and the context of the work. I've designed the prompts in modular way to provide high confidence and easy debugging. I have already designed all of the prompts and the intro for the user.

Of course. Here is the step-by-step, verbatim text to send to the Replit AI assistant.

For the best results, send each prompt one at a time. Wait for the AI to complete the task before sending the next one. This creates a focused, iterative workflow.

Prompt 1: Project Initialization and Context
(Copy and paste the entire text in the box below as your first message to Replit)

Hello. We are going to build the backend API for a construction management app called BuilderOS.

The Tech Stack: Please use Node.js with the Express framework. We will be connecting to a PostgreSQL database.

The Master Plan: Here is the complete database schema and the full OpenAPI specification for the entire application. Please use this as a reference guide for structure, naming conventions, and data types. Do not build everything in this plan yet. Just understand the overall structure and be prepared to use it as a reference.

--- DATABASE SCHEMA START ---
-- ================================
-- CORE ENTITIES
-- ================================
-- Users and Authentication
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    role VARCHAR(50) NOT NULL CHECK (role IN ('admin', 'pm', 'owner', 'vendor', 'viewer')),
    company_id UUID REFERENCES companies(id),
    is_active BOOLEAN DEFAULT true,
    last_login_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE companies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    type VARCHAR(50) CHECK (type IN ('general_contractor', 'owner', 'vendor', 'consultant')),
    address JSONB,
    phone VARCHAR(20),
    email VARCHAR(255),
    license_number VARCHAR(100),
    insurance_info JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- Properties/Projects
CREATE TABLE properties (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    address TEXT NOT NULL,
    property_type VARCHAR(100) NOT NULL,
    project_type VARCHAR(100) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'planning',
    owner_id UUID REFERENCES companies(id),
    pm_id UUID REFERENCES users(id),
    budget_total DECIMAL(12,2),
    budget_contingency DECIMAL(12,2),
    start_date DATE,
    target_completion DATE,
    actual_completion DATE,
    square_footage INTEGER,
    lot_size DECIMAL(10,2),
    coordinates POINT,
    permits_required JSONB,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- ================================
-- SCHEDULE & MILESTONES
-- ================================
CREATE TABLE milestones (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    milestone_type VARCHAR(50) NOT NULL,
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'active', 'blocked', 'complete', 'cancelled')),
    planned_start DATE,
    planned_end DATE,
    actual_start DATE,
    actual_end DATE,
    dependencies JSONB,
    blockers JSONB,
    completion_percentage INTEGER DEFAULT 0 CHECK (completion_percentage >= 0 AND completion_percentage <= 100),
    assigned_to UUID REFERENCES users(id),
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- ================================
-- FINANCIAL MANAGEMENT
-- ================================
CREATE TABLE budget_lines (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
    category VARCHAR(100) NOT NULL,
    scope_description TEXT NOT NULL,
    budgeted_amount DECIMAL(12,2) NOT NULL,
    committed_amount DECIMAL(12,2) DEFAULT 0,
    spent_amount DECIMAL(12,2) DEFAULT 0,
    vendor_id UUID REFERENCES companies(id),
    contract_number VARCHAR(100),
    milestone_id UUID REFERENCES milestones(id),
    requires_bids BOOLEAN DEFAULT true,
    minimum_bids INTEGER DEFAULT 3,
    status VARCHAR(50) DEFAULT 'budgeted',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- ================================
-- DOCUMENTS & FILES
-- ================================
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    property_id UUID REFERENCES properties(id) ON DELETE CASCADE,
    vendor_id UUID REFERENCES companies(id),
    milestone_id UUID REFERENCES milestones(id),
    rfi_id UUID REFERENCES rfis(id),
    punch_item_id UUID REFERENCES punch_list_items(id),
    change_order_id UUID REFERENCES change_orders(id),
    document_type VARCHAR(100) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    file_path VARCHAR(500) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size BIGINT,
    mime_type VARCHAR(100),
    version INTEGER DEFAULT 1,
    is_current BOOLEAN DEFAULT true,
    uploaded_by UUID REFERENCES users(id),
    tags TEXT[],
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- ================================
-- FUNCTIONS & TRIGGERS
-- ================================
-- Update timestamp trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';
CREATE TRIGGER update_properties_updated_at BEFORE UPDATE ON properties FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_milestones_updated_at BEFORE UPDATE ON milestones FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_budget_lines_updated_at BEFORE UPDATE ON budget_lines FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_invoices_updated_at BEFORE UPDATE ON invoices FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
--- DATABASE SCHEMA END ---

--- API SPECIFICATION START ---
openapi: 3.0.3
info:
  title: BuilderOS PM API
  version: 1.0.0
servers:
  - url: /api/v1
components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
security:
  - BearerAuth: []
--- API SPECIFICATION END ---

Our First Task: Please set up the basic Express server structure. Create a single health-check endpoint at GET /health that returns a 200 OK status with the JSON message {"status": "ok", "timestamp": "ISO_DATE_STRING"}.
Prompt 2: User Authentication Endpoint
(Once Replit completes the first task, send this exact prompt)

Great. Now, let's implement the User Login endpoint. This corresponds to the `POST /auth/login` endpoint from the context I provided and uses the `users` table.

Requirements:
1. Create a new route at `POST /api/v1/auth/login`.
2. It must accept an `email` and `password` in the JSON request body.
3. Find the user by email in the database.
4. Securely compare the provided password with the `password_hash` in the database using the `bcrypt` library.
5. On success, generate a JWT containing the user's `id` and `role`.
6. Return a `200 OK` response containing the JWT and user information.
Prompt 3: Create Project Endpoint
(After the login endpoint is working, send this)

Perfect. Now, create the endpoint to add a new project. This corresponds to `POST /properties` and uses the `properties` table.

Requirements:
1. Create a new authenticated route at `POST /api/v1/projects`. It should require a valid JWT.
2. It must accept an `address` and `project_type` in the JSON request body.
3. The logged-in user's ID should be set as the `pm_id`.
4. Insert the new project into the `properties` table.
5. Return a `201 Created` response containing the full object of the newly created project, including its new UUID.
Prompt 4: Get Projects Endpoint
(Next, send this prompt)

Now, let's create the endpoint to view all projects. This corresponds to `GET /properties`.

Requirements:
1. Create a new authenticated route at `GET /api/v1/projects`.
2. It should query the `properties` table for all projects where the `pm_id` matches the ID of the logged-in user.
3. Return a `200 OK` response with a JSON array of the found project objects.
Prompt 5: Create Milestone Endpoint
(Next, send this prompt)

Excellent. Let's add the endpoint to create a milestone for a project. This corresponds to `POST /properties/{propertyId}/milestones`.

Requirements:
1. Create an authenticated route at `POST /api/v1/projects/:projectId/milestones`.
2. It must accept `name`, `milestone_type`, and `planned_end` in the JSON request body.
3. The `property_id` will come from the URL parameter.
4. Insert the new milestone into the `milestones` table.
5. Return a `201 Created` response with the full object of the newly created milestone.
Prompt 6: Update Milestone Endpoint
(Next, send this prompt)

Now, create the endpoint to update a milestone's status. This corresponds to `PUT /milestones/{milestoneId}`.

Requirements:
1. Create an authenticated route at `PUT /api/v1/milestones/:milestoneId`.
2. It must accept `status` and `actual_end` in the JSON request body.
3. Update the corresponding record in the `milestones` table.
4. Return a `200 OK` response with the complete, updated milestone object.
Prompt 7: Create Company (Vendor) Endpoint
(Next, send this prompt)

Let's add the ability to create a vendor.

Requirements:
1. Create an authenticated route at `POST /api/v1/companies`.
2. It must accept `name` and `type` (e.g., 'vendor') in the JSON request body.
3. Insert the new company into the `companies` table.
4. Return a `201 Created` response with the full new company object.