// Add these methods to your existing server/storage.ts file

import { db } from './db';
import { 
  properties, milestones, permits, budgetLines, 
  vendors, bids, siteReports, risks, documents, users 
} from '@shared/schema';
import { eq, desc, and } from 'drizzle-orm';

export const storage = {
  // ... existing methods ...

  // Property methods
  async getProperties() {
    return await db.select().from(properties).orderBy(desc(properties.createdAt));
  },

  async getProperty(id: string) {
    const result = await db.select().from(properties).where(eq(properties.id, id));
    return result[0];
  },

  async createProperty(data: any) {
    const result = await db.insert(properties).values(data).returning();
    return result[0];
  },

  async updateProperty(id: string, data: any) {
    const result = await db.update(properties)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(properties.id, id))
      .returning();
    return result[0];
  },

  // Milestone methods
  async getMilestones(propertyId: string) {
    return await db.select()
      .from(milestones)
      .where(eq(milestones.propertyId, propertyId))
      .orderBy(milestones.order);
  },

  async createMilestone(data: any) {
    const result = await db.insert(milestones).values(data).returning();
    return result[0];
  },

  async updateMilestone(id: string, data: any) {
    const result = await db.update(milestones)
      .set(data)
      .where(eq(milestones.id, id))
      .returning();
    return result[0];
  },

  // Budget methods
  async getBudgetLines(propertyId: string) {
    return await db.select()
      .from(budgetLines)
      .where(eq(budgetLines.propertyId, propertyId));
  },

  async createBudgetLine(data: any) {
    const result = await db.insert(budgetLines).values(data).returning();
    return result[0];
  },

  async updateBudgetLine(id: string, data: any) {
    const result = await db.update(budgetLines)
      .set(data)
      .where(eq(budgetLines.id, id))
      .returning();
    return result[0];
  },

  // Permit methods
  async getPermits(propertyId: string) {
    return await db.select()
      .from(permits)
      .where(eq(permits.propertyId, propertyId));
  },

  async createPermit(data: any) {
    const result = await db.insert(permits).values(data).returning();
    return result[0];
  },

  async updatePermit(id: string, data: any) {
    const result = await db.update(permits)
      .set(data)
      .where(eq(permits.id, id))
      .returning();
    return result[0];
  },

  // Site Report methods
  async getSiteReports(propertyId: string) {
    return await db.select()
      .from(siteReports)
      .where(eq(siteReports.propertyId, propertyId))
      .orderBy(desc(siteReports.reportDate));
  },

  async createSiteReport(data: any) {
    const result = await db.insert(siteReports).values(data).returning();
    return result[0];
  },

  // Risk methods
  async getRisks(propertyId: string) {
    return await db.select()
      .from(risks)
      .where(eq(risks.propertyId, propertyId));
  },

  async createRisk(data: any) {
    const result = await db.insert(risks).values(data).returning();
    return result[0];
  },

  async updateRisk(id: string, data: any) {
    const result = await db.update(risks)
      .set(data)
      .where(eq(risks.id, id))
      .returning();
    return result[0];
  },

  // Vendor methods
  async getVendors() {
    return await db.select().from(vendors);
  },

  async createVendor(data: any) {
    const result = await db.insert(vendors).values(data).returning();
    return result[0];
  },

  async updateVendor(id: string, data: any) {
    const result = await db.update(vendors)
      .set(data)
      .where(eq(vendors.id, id))
      .returning();
    return result[0];
  },

  // Bid methods
  async getBids(propertyId: string) {
    return await db.select()
      .from(bids)
      .where(eq(bids.propertyId, propertyId));
  },

  async createBid(data: any) {
    const result = await db.insert(bids).values(data).returning();
    return result[0];
  },

  // Document methods
  async createDocument(data: any) {
    const result = await db.insert(documents).values(data).returning();
    return result[0];
  },

  async getDocuments(propertyId: string) {
    return await db.select()
      .from(documents)
      .where(eq(documents.propertyId, propertyId))
      .orderBy(desc(documents.createdAt));
  },

  // Report generation
  async generateWeeklyReport() {
    const props = await this.getProperties();
    const report = {
      weekEnding: new Date().toISOString(),
      properties: []
    };

    for (const property of props) {
      const milestones = await this.getMilestones(property.id);
      const reports = await this.getSiteReports(property.id);
      const risks = await this.getRisks(property.id);
      
      report.properties.push({
        address: property.address,
        progress: property.progress,
        activeMilestones: milestones.filter(m => m.status === 'active'),
        recentReports: reports.slice(0, 3),
        openRisks: risks.filter(r => r.status === 'open')
      });
    }

    return report;
  },

  async generateMonthlyReport() {
    const props = await this.getProperties();
    const report = {
      month: new Date().toISOString(),
      totalBudget: 0,
      totalSpent: 0,
      totalCommitted: 0,
      properties: []
    };

    for (const property of props) {
      const budget = await this.getBudgetLines(property.id);
      const milestones = await this.getMilestones(property.id);
      
      const propertySpent = budget.reduce((sum, line) => sum + parseFloat(line.invoiced), 0);
      const propertyCommitted = budget.reduce((sum, line) => sum + parseFloat(line.contract), 0);